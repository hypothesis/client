'use strict';

/* eslint-disable no-undef */var _promise = require('babel-runtime/core-js/promise');var _promise2 = _interopRequireDefault(_promise);var _typeof2 = require('babel-runtime/helpers/typeof');var _typeof3 = _interopRequireDefault(_typeof2);function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

var fs = require('fs');
var path = require('path');
var chalk = require('chalk');
var findup = require('findup-sync');
var _ = require('lodash');
var semver = require('semver');
var spawn = require('child_process').spawn;
var spawnSync = require('child_process').spawnSync;

/* eslint-enable no-undef */

var checkDependenciesHelper = function checkDependenciesHelper(syncOrAsync, config, callback) {
    // We treat the signature:
    //     checkDependencies(callback)
    // as:
    //     checkDependencies({}, callback)

    if (syncOrAsync === 'async') {
        // Catch all cases where `config` is not an object - even if it's not a function
        // so it's useless here, we need it to be assigned to `callback` to provide
        // to the error message.
        if (typeof callback !== 'function' && ((typeof config === 'undefined' ? 'undefined' : (0, _typeof3.default)(config)) !== 'object' || config == null)) {
            callback = config;
            config = null;
        }
        if (typeof callback !== 'function') {
            if (callback == null) {
                // In the async mode we return the promise anyway; assign callback
                // to noop to keep code consistency.
                callback = _.noop;
            } else {
                // If callback was simply not provided, we assume the user wanted
                // to handle the returned promise. If it was passed but not a function
                // we assume user error and throw.
                throw new Error('The provided callback wasn\'t a function! Got:', callback);
            }
        }
    }

    var win32 = process.platform === 'win32';
    var output = { log: [], error: [] };

    var depsDirName = void 0,packageJson = void 0,pkgManagerPath = void 0;

    var installPrunePromise = _promise2.default.resolve();
    var success = true;
    var installNeeded = false;
    var pruneNeeded = false;

    var options = _.defaults({}, config, {
        packageManager: 'npm',
        onlySpecified: false,
        install: false,
        scopeList: ['dependencies', 'devDependencies'],
        optionalScopeList: ['optionalDependencies'],
        verbose: false,
        checkGitUrls: false,
        checkCustomPackageNames: false,
        log: console.log.bind(console),
        error: console.error.bind(console) });


    var packageJsonName = options.packageManager === 'npm' ? 'package.json' : 'bower.json';
    var packageJsonRegex = options.packageManager === 'npm' ? /package\.json$/ : /bower\.json$/;
    depsDirName = options.packageManager === 'npm' ? 'node_modules' : 'bower_components';

    var log = function log(message) {
        output.log.push(message);
        if (options.verbose) {
            options.log(message);
        }
    };

    var error = function error(message) {
        output.error.push(message);
        if (options.verbose) {
            options.error(message);
        }
    };

    var finish = function finish() {
        output.status = success ? 0 : 1;
        if (syncOrAsync === 'async') {
            callback(output);
            return new _promise2.default(function (resolve) {return resolve(output);});
        }
        return output;
    };

    var missingPackageJson = function missingPackageJson() {
        success = false;
        error('Missing ' + packageJsonName + '!');
        return finish();
    };

    options.packageDir = options.packageDir || findup(packageJsonName);
    if (!options.packageDir) {
        return missingPackageJson();
    }
    options.packageDir = path.resolve(options.packageDir.replace(packageJsonRegex, ''));

    packageJson = options.packageDir + '/' + packageJsonName;
    if (!fs.existsSync(packageJson)) {
        return missingPackageJson();
    }
    packageJson = require(packageJson);

    if (options.packageManager === 'bower') {
        var bowerConfig = require('bower-config').create(options.packageDir).load();
        depsDirName = bowerConfig._config.directory;
    }

    // Bower uses a different name (with a dot) for package data of dependencies.
    var depsJsonName = options.packageManager === 'npm' ? 'package.json' : '.bower.json';

    if (options.packageManager === 'bower') {
        // Allow a local bower.
        pkgManagerPath = findup('node_modules/bower/bin/bower');
    }

    var depsDir = options.packageDir + '/' + depsDirName;

    var getDepsMappingsFromScopeList = function getDepsMappingsFromScopeList(scopeList) {return (
            // Get names of all packages specified in package.json/bower.json at keys from scopeList
            // together with specified version numbers.
            scopeList.reduce(function (result, scope) {return _.merge(result, packageJson[scope] || {});}, {}));};

    // Make sure each package from `scopeList` is present and matches the specified version range.
    // Packages from `optionalScopeList` may not be present but if they are, they are required
    // to match the specified version range.
    var checkPackage = function checkPackage(_ref) {var name = _ref.name;var versionString = _ref.versionString;var isOptional = _ref.isOptional;
        var depDir = depsDir + '/' + name;
        var depJson = depDir + '/' + depsJsonName;

        if (!fs.existsSync(depDir) || !fs.existsSync(depJson)) {
            if (isOptional) {
                log(name + ': ' + chalk.red('not installed!'));
            } else {
                error(name + ': ' + chalk.red('not installed!'));
                success = false;
            }
            return;
        }

        // Let's look if we can get a valid version from a Git URL
        if (options.checkGitUrls && /\.git.*#v?(.+)$/.test(versionString)) {
            versionString = /#v?(.+)$/.exec(versionString)[1];
            if (!semver.valid(versionString)) {
                return;
            }
        }

        // Quick and dirty check - make sure we're not dealing with a URL
        if (/\//.test(versionString)) {
            return;
        }

        // Bower has the option to specify a custom name, e.g. 'packageOld' : 'package#1.2.3'
        if (options.checkCustomPackageNames && options.packageManager !== 'npm') {
            // Let's look if we can get a valid version from a custom package name (with a # in it)
            if (/\.*#v?(.+)$/.test(versionString)) {
                versionString = /#v?(.+)$/.exec(versionString)[1];
                if (!semver.valid(versionString)) {
                    return;
                }
            }
        }

        // If we are dealing with a custom package name, semver check won't work - skip it
        if (/#/.test(versionString)) {
            return;
        }

        // Skip version checks for 'latest' - the semver module won't help here and the check
        // would have to consult the npm server, making the operation slow.
        if (versionString === 'latest') {
            return;
        }

        var depVersion = require(depJson).version;
        if (semver.satisfies(depVersion, versionString)) {
            log(name + ': installed: ' + chalk.green(depVersion) + ', expected: ' +
            chalk.green(versionString));
        } else {
            success = false;
            error(name + ': installed: ' + chalk.red(depVersion) + ', expected: ' +
            chalk.green(versionString));
        }
    };

    var depsMappings = getDepsMappingsFromScopeList(options.scopeList);
    var optionalDepsMappings = getDepsMappingsFromScopeList(options.optionalScopeList);
    var fullDepsMappings = _.assign({}, depsMappings, optionalDepsMappings);

    _.forEach(depsMappings, function (versionString, name) {
        checkPackage({ name: name, versionString: versionString, isOptional: false });
    });

    _.forEach(optionalDepsMappings, function (versionString, name) {
        checkPackage({ name: name, versionString: versionString, isOptional: true });
    });

    installNeeded = !success;

    if (options.onlySpecified) {
        fs.
        readdirSync(depsDir)

        // Ignore hidden directories
        .filter(function (depName) {return depName[0] !== '.';})

        // Ignore files
        .filter(function (depName) {return fs.lstatSync(depsDir + '/' + depName).isDirectory();}).

        forEach(function (depName) {
            var depSubDirName = void 0;

            // Scoped packages
            if (depName[0] === '@') {
                depName = fs.readdirSync(depsDir + '/' + depName)[0];

                // Ignore weird directories - if it just looks like a scoped package but
                // isn't one, just skip it.
                if (depSubDirName && !fullDepsMappings[depName]) {
                    success = false;
                    pruneNeeded = true;
                    error('Package ' + depName + ' installed, though it shouldn\'t be');
                }
                return;
            }

            // Regular packages
            if (!fullDepsMappings[depName]) {
                success = false;
                pruneNeeded = true;
                error('Package ' + depName + ' installed, though it shouldn\'t be');
            }
        });
    }

    if (success) {
        output.depsWereOk = true;
        return finish();
    }
    output.depsWereOk = false;

    if (!options.install) {
        if (options.onlySpecified) {
            error('Invoke ' + chalk.green(options.packageManager + ' prune') + ' and ' +
            chalk.green(options.packageManager + ' install') + ' to install missing packages and remove excessive ones');

        } else {
            error('Invoke ' + chalk.green(options.packageManager + ' install') + ' to install missing packages');

        }
        return finish();
    }


    var installOrPrune = function installOrPrune(mode) {
        log('Invoking ' + chalk.green(options.packageManager + ' ' + mode) + '...');

        // If we're using a direct path, on Windows we need to invoke it via `node path`, not
        // `cmd /c path`. In UNIX systems we can execute the command directly so no need to wrap.
        var msg = void 0,spawnReturn = void 0;
        var method = syncOrAsync === 'sync' ? spawnSync : spawn;

        if (win32) {
            spawnReturn = method(pkgManagerPath ? 'node' : 'cmd',
            (pkgManagerPath ? [pkgManagerPath] : ['/c', options.packageManager]).concat([mode]),
            {
                cwd: options.packageDir,
                stdio: 'inherit' });

        } else {
            spawnReturn = method(options.packageManager,
            [mode],
            {
                cwd: options.packageDir,
                stdio: 'inherit' });

        }

        if (syncOrAsync === 'sync') {
            if (spawnReturn.status !== 0) {
                msg = options.packageManager + ' ' + mode + ' failed with code: ' +
                chalk.red(spawnReturn.status);
                throw new Error(msg);
            }
            return null;
        }
        return new _promise2.default(function (resolve, reject) {
            spawnReturn.on('close', function (code) {
                if (code === 0) {
                    resolve();
                    return;
                }
                msg = options.packageManager + ' ' + mode + ' failed with code: ' +
                chalk.red(code);
                error(msg);
                reject(msg);
            });
        });
    };

    var installMissing = function installMissing() {return installOrPrune('install');};
    var pruneExcessive = function pruneExcessive() {return installOrPrune('prune');};

    if (syncOrAsync === 'sync') {
        try {
            if (installNeeded) {
                installMissing();
            }

            if (pruneNeeded) {
                pruneExcessive();
            }

            success = true;
        } catch (error) {
            success = false;
        }
        return finish();
    }

    // Async scenario
    if (installNeeded) {
        installPrunePromise = installPrunePromise.then(installMissing);
    }

    if (pruneNeeded) {
        installPrunePromise = installPrunePromise.then(pruneExcessive);
    }

    return installPrunePromise.
    then(function () {
        success = true;
        return finish();
    }).
    catch(function () {
        success = false;
        return finish();
    });
};

module.exports = function () {for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {args[_key] = arguments[_key];}return checkDependenciesHelper.apply(undefined, ['async'].concat(args));};

module.exports.sync = function () {for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {args[_key2] = arguments[_key2];}
    if (!spawnSync) {
        throw new Error([
        'Your version of Node.js doesn\'t support child_process.spawnSync.',
        'Update Node.js or use require(\'checkDependencies\') instead of',
        'require(\'checkDependencies\').sync.'].
        join(' '));
    }
    return checkDependenciesHelper.apply(undefined, ['sync'].concat(args));
};
//# sourceMappingURL=check-dependencies.js.map
