/*!
 * angular-translate - v2.17.0 - 2017-12-21
 * 
 * Copyright (c) 2017 The angular-translate team, Pascal Precht; Licensed MIT
 */
!function(t,e){"function"==typeof define&&define.amd?define([],function(){return e()}):"object"==typeof module&&module.exports?module.exports=e():e()}(0,function(){function t(){"use strict";function t(t,e,r){this.name=t,this.isActive=!0,this.tables={},this.priority=e||0,this.langPromises={},this.urlTemplate=r}function e(t){return Object.prototype.hasOwnProperty.call(o,t)}function r(t){return angular.isString(t)&&""!==t}function a(t){if(!r(t))throw new TypeError("Invalid type of a first argument, a non-empty string expected.");return e(t)&&o[t].isActive}function n(t,e){for(var r in e)e[r]&&e[r].constructor&&e[r].constructor===Object?(t[r]=t[r]||{},n(t[r],e[r])):t[r]=e[r];return t}function i(){var t=[];for(var e in o)o[e].isActive&&t.push(o[e]);return t.sort(function(t,e){return t.priority-e.priority}),t}t.prototype.parseUrl=function(t,e){return angular.isFunction(t)?t(this.name,e):t.replace(/\{part\}/g,this.name).replace(/\{lang\}/g,e)},t.prototype.getTable=function(t,e,r,a,n,i){var o=this,s=this.langPromises[t],l=e.defer(),u=function(){return r(angular.extend({method:"GET",url:o.parseUrl(o.urlTemplate||n,t)},a))},c=function(e){o.tables[t]=e,l.resolve(e)},f=function(){l.reject(o.name)},p=function(){u().then(function(t){c(t.data)},function(e){i?i(o.name,t,e).then(c,f):f()})};return this.tables[t]?l.resolve(this.tables[t]):(s?s.then(l.resolve,p):p(),this.langPromises[t]=l.promise),l.promise};var o={};this.addPart=function(a,n,i){if(!r(a))throw new TypeError("Couldn't add part, part name has to be a string!");return e(a)||(o[a]=new t(a,n,i)),o[a].isActive=!0,this},this.setPart=function(a,n,i){if(!r(a))throw new TypeError("Couldn't set part.`lang` parameter has to be a string!");if(!r(n))throw new TypeError("Couldn't set part.`part` parameter has to be a string!");if("object"!=typeof i||null===i)throw new TypeError("Couldn't set part. `table` parameter has to be an object!");return e(n)||(o[n]=new t(n),o[n].isActive=!1),o[n].tables[a]=i,this},this.deletePart=function(t){if(!r(t))throw new TypeError("Couldn't delete part, first arg has to be string.");return e(t)&&(o[t].isActive=!1),this},this.isPartAvailable=a,this.$get=["$rootScope","$injector","$q","$http","$log",function(s,l,u,c,f){var p=function(t){if(!r(t.key))throw new TypeError("Unable to load data, a key is not a non-empty string.");if(!r(t.urlTemplate)&&!angular.isFunction(t.urlTemplate))throw new TypeError("Unable to load data, a urlTemplate is not a non-empty string or not a function.");var e=t.loadFailureHandler;if(void 0!==e){if(!angular.isString(e))throw new Error("Unable to load data, a loadFailureHandler is not a string.");e=l.get(e)}var a=[],o=i();angular.forEach(o,function(r){a.push(r.getTable(t.key,u,c,t.$http,t.urlTemplate,e)),r.urlTemplate=r.urlTemplate||t.urlTemplate});var d=!1,h=s.$on("$translatePartialLoaderStructureChanged",function(){d=!0});return u.all(a).then(function(){if(h(),d){if(!t.__retries)return t.__retries=(t.__retries||0)+1,p(t);f.warn("The partial loader has detected a multiple structure change (with addPort/removePart) while loading translations. You should consider using promises of $translate.use(lang) and $translate.refresh(). Also parts should be added/removed right before an explicit refresh if possible.")}var e={};return o=i(),angular.forEach(o,function(r){n(e,r.tables[t.key])}),e},function(){return h(),u.reject(t.key)})};return p.addPart=function(a,n,i){if(!r(a))throw new TypeError("Couldn't add part, first arg has to be a string");return e(a)?o[a].isActive||(o[a].isActive=!0,s.$emit("$translatePartialLoaderStructureChanged",a)):(o[a]=new t(a,n,i),s.$emit("$translatePartialLoaderStructureChanged",a)),p},p.deletePart=function(t,a){if(!r(t))throw new TypeError("Couldn't delete part, first arg has to be string");if(void 0===a)a=!1;else if("boolean"!=typeof a)throw new TypeError("Invalid type of a second argument, a boolean expected.");if(e(t)){var n=o[t].isActive;if(a){var i=l.get("$translate").loaderCache();"string"==typeof i&&(i=l.get(i)),"object"==typeof i&&angular.forEach(o[t].tables,function(e,r){i.remove(o[t].parseUrl(o[t].urlTemplate,r))}),delete o[t]}else o[t].isActive=!1;n&&s.$emit("$translatePartialLoaderStructureChanged",t)}return p},p.isPartLoaded=function(t,e){return angular.isDefined(o[t])&&angular.isDefined(o[t].tables[e])},p.getRegisteredParts=function(){var t=[];return angular.forEach(o,function(e){e.isActive&&t.push(e.name)}),t},p.isPartAvailable=a,p}]}return angular.module("pascalprecht.translate").provider("$translatePartialLoader",t),t.displayName="$translatePartialLoader","pascalprecht.translate"});