import { ImageTextLayer } from '../image-text-layer';

// Sizes of characters and lines used in character bounding boxes generated by
// these tests, expressed as percentages of the image size.
const charWidth = 4;
const charHeight = 8;
const charSpacing = 5;
const lineSpacing = 10;

/**
 * Return a `[left, top, width, height]` tuple of the expected position of
 * a word in the text layer.
 */
function expectedBoxOffsetAndSize(imageWidth, imageHeight, lineIndex, text) {
  const xScale = imageWidth / 100;
  const yScale = imageHeight / 100;

  const width = (text.length - 1) * charSpacing * xScale + charWidth * xScale;
  const height = charHeight * yScale;

  return [0, lineSpacing * lineIndex * yScale, width, height];
}

/**
 * Create character bounding box data for text in an image.
 *
 * The generated data positions each word on a separate line.
 */
function createCharBoxes(text) {
  const charBoxes = [];
  let lineIndex = 0;
  let charIndex = 0;

  for (let char of text) {
    charBoxes.push({
      left: (charIndex * charSpacing) / 100,
      right: (charIndex * charSpacing + charWidth) / 100,
      top: (lineIndex * lineSpacing) / 100,
      bottom: (lineIndex * lineSpacing + charHeight) / 100,
    });

    if (char === ' ') {
      charIndex = 0;
      ++lineIndex;
    } else {
      ++charIndex;
    }
  }
  return charBoxes;
}

describe('ImageTextLayer', () => {
  let textLayers;
  let containers;

  function createPageImage() {
    const container = document.createElement('div');
    const image = document.createElement('img');

    // Image size chosen so 1% == 5px, to make the math easy.
    image.style.width = '500px';
    image.style.height = '500px';

    container.append(image);

    document.body.append(container);
    containers.push(container);

    return { container, image };
  }

  function createTextLayer(...args) {
    const textLayer = new ImageTextLayer(...args);
    textLayers.push(textLayer);
    return textLayer;
  }

  function getWordBoxes(textLayer) {
    return [...textLayer.container.querySelectorAll('span')];
  }

  beforeEach(() => {
    containers = [];
    textLayers = [];
  });

  afterEach(() => {
    containers.forEach(c => c.remove());
    textLayers.forEach(tl => tl.destroy());
  });

  it('creates a <hypothesis-text-layer> element above the image', () => {
    const { container, image } = createPageImage();

    // nb. Text starts with a space to exercise an extra code path in the text
    // layer builder.
    const imageText = ' some text in the image';

    createTextLayer(image, createCharBoxes(imageText), imageText);

    const textLayerEl = container.querySelector('hypothesis-text-layer');
    assert.instanceOf(textLayerEl, HTMLElement);
    assert.equal(image.nextSibling, textLayerEl);
    assert.equal(container.style.position, 'relative');
    assert.equal(textLayerEl.style.position, 'absolute');
    assert.equal(textLayerEl.style.mixBlendMode, 'multiply');
  });

  it('throws if char box array and text have different lengths', () => {
    const { image } = createPageImage();
    const imageText = 'some text in the image';

    assert.throws(() => {
      const charBoxes = createCharBoxes(imageText).slice(0, -1);
      createTextLayer(image, charBoxes, imageText);
    }, 'Char boxes length does not match text length');
  });

  it('creates elements in the text layer for each word in the image', () => {
    const { image } = createPageImage();
    const imageText = 'some words here';
    const textLayer = createTextLayer(
      image,
      createCharBoxes(imageText),
      imageText
    );

    assert.equal(textLayer.container.textContent, 'some words here ');
    const wordSpans = getWordBoxes(textLayer);
    assert.equal(wordSpans.length, imageText.split(' ').length);
    assert.deepEqual(
      wordSpans.map(ws => ws.textContent),
      ['some', 'words', 'here']
    );

    const imageBox = image.getBoundingClientRect();
    const wordBoxPositions = wordSpans.map(span => {
      const wordBox = span.getBoundingClientRect();
      return [
        wordBox.left - imageBox.left,
        wordBox.top - imageBox.top,
        wordBox.width,
        wordBox.height,
      ].map(coord => Math.floor(coord));
    });

    const imageWidth = parseInt(image.style.width);
    const imageHeight = parseInt(image.style.height);

    const expectedPositions = [
      expectedBoxOffsetAndSize(imageWidth, imageHeight, 0, 'some'),
      expectedBoxOffsetAndSize(imageWidth, imageHeight, 1, 'words'),
      expectedBoxOffsetAndSize(imageWidth, imageHeight, 2, 'here'),
    ];
    assert.deepEqual(wordBoxPositions, expectedPositions);
  });

  it('updates size and position of text layer elements when window is resized', () => {
    const { image } = createPageImage();
    const imageText = 'some text in the image';

    const clock = sinon.useFakeTimers();
    try {
      const textLayer = createTextLayer(
        image,
        createCharBoxes(imageText),
        imageText
      );

      const originalBoxes = getWordBoxes(textLayer).map(box =>
        box.getBoundingClientRect()
      );

      // Rescale image to 3/5 of original size.
      image.style.width = '300px';
      image.style.height = '300px';

      // Notify text layer that image has been resized. We currently assume
      // that this always corresponds to a window resize.
      window.dispatchEvent(new Event('resize'));
      clock.tick(100);

      // Check that the positions and sizes of each text box were changed to
      // reflect the new scale of the image.
      const ratio = 3 / 5;
      const imageBox = image.getBoundingClientRect();
      const newBoxes = getWordBoxes(textLayer).map(box =>
        box.getBoundingClientRect()
      );

      const tolerance = 0.01;
      assert.equal(originalBoxes.length, newBoxes.length);
      for (let [i, originalBox] of originalBoxes.entries()) {
        const newBox = newBoxes[i];

        const leftGap = originalBox.left - imageBox.left;
        const newLeftGap = newBox.left - imageBox.left;
        assert.approximately(leftGap * ratio, newLeftGap, tolerance);

        const topGap = originalBox.top - imageBox.top;
        const newTopGap = newBox.top - imageBox.top;
        assert.approximately(topGap * ratio, newTopGap, tolerance);

        assert.approximately(
          originalBox.width * ratio,
          newBox.width,
          tolerance
        );
        assert.approximately(
          originalBox.height * ratio,
          newBox.height,
          tolerance
        );
      }
    } finally {
      clock.restore();
    }
  });

  describe('#destroy', () => {
    it('removes the <hypothesis-text-layer> element', () => {
      const { container, image } = createPageImage();
      const imageText = 'some text in the image';
      const textLayer = createTextLayer(
        image,
        createCharBoxes(imageText),
        imageText
      );

      textLayer.destroy();

      const textLayerEl = container.querySelector('hypothesis-text-layer');
      assert.isNull(textLayerEl);
    });
  });
});
