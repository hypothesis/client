import { Button, CardActions, Select } from '@hypothesis/frontend-shared';
import { useCallback, useEffect, useId, useMemo, useState } from 'preact/hooks';

import { isObject } from '../../../shared/is-object';
import { readJSONFile } from '../../../shared/read-json-file';
import type { APIAnnotationData } from '../../../types/api';
import { annotationDisplayName } from '../../helpers/annotation-user';
import { withServices } from '../../service-context';
import type { ExportContent } from '../../services/annotations-exporter';
import type { ImportAnnotationsService } from '../../services/import-annotations';
import { useSidebarStore } from '../../store';
import FileInput from './FileInput';
import LoadingSpinner from './LoadingSpinner';

/**
 * Parse a file generated by the annotation exporter and return the extracted
 * annotations.
 */
async function parseExportContent(file: File): Promise<APIAnnotationData[]> {
  let json;
  try {
    json = await readJSONFile(file);
  } catch (err) {
    throw new Error('Not a valid JSON file');
  }

  // Perform some very rudimentary validation of the file content, just enough
  // to catch issues where the user picked the wrong kind of JSON file.
  if (!isObject(json) || !Array.isArray((json as any).annotations)) {
    throw new Error('Not a valid Hypothesis JSON file');
  }

  return (json as ExportContent).annotations;
}

type UserAnnotationCount = {
  userid: string;
  displayName: string;

  /** Number of annotations made by this user. */
  count: number;
};

/**
 * Generate an alphabetized list of authors and their annotation counts.
 */
function annotationCountsByUser(
  anns: APIAnnotationData[],
  getDisplayName: (ann: APIAnnotationData) => string,
): UserAnnotationCount[] {
  const userInfo = new Map<string, UserAnnotationCount>();
  for (const ann of anns) {
    let info = userInfo.get(ann.user);
    if (!info) {
      info = { userid: ann.user, displayName: getDisplayName(ann), count: 0 };
      userInfo.set(ann.user, info);
    }
    info.count += 1;
  }
  const userInfos = [...userInfo.values()];
  userInfos.sort((a, b) => a.displayName.localeCompare(b.displayName));
  return userInfos;
}

export type ImportAnnotationsProps = {
  importAnnotationsService: ImportAnnotationsService;
};

/**
 * Content of "Import" tab of annotation share dialog.
 *
 * This allows the user to select a previously exported file of annotations
 * and initiate an import via {@link ImportAnnotationsService}.
 */
function ImportAnnotations({
  importAnnotationsService,
}: ImportAnnotationsProps) {
  const [file, setFile] = useState<File | null>(null);

  // Annotations extracted from `file`.
  const [annotations, setAnnotations] = useState<APIAnnotationData[] | null>(
    null,
  );
  const [error, setError] = useState<string | null>(null);

  // User whose annotations are going to be imported.
  const [selectedUser, setSelectedUser] = useState<string | null>(null);

  const store = useSidebarStore();
  const currentUser = store.profile().userid;

  const defaultAuthority = store.defaultAuthority();
  const displayNamesEnabled = store.isFeatureEnabled('client_display_names');
  const getDisplayName = useCallback(
    (ann: APIAnnotationData) =>
      annotationDisplayName(ann, defaultAuthority, displayNamesEnabled),
    [defaultAuthority, displayNamesEnabled],
  );
  const userList = useMemo(
    () =>
      annotations ? annotationCountsByUser(annotations, getDisplayName) : null,
    [annotations, getDisplayName],
  );

  const importsPending = store.importsPending();

  // Parse input file, extract annotations and update the user list.
  useEffect(() => {
    if (!currentUser || !file) {
      return;
    }
    setAnnotations(null);
    setError(null);
    setSelectedUser(null);
    parseExportContent(file)
      .then(annotations => {
        setAnnotations(annotations);

        // Pre-select the current user in the list, if at least one of the
        // annotations was authored by them.
        const userMatch = annotations.some(ann => ann.user === currentUser);
        setSelectedUser(userMatch ? currentUser : null);
      })
      .catch(err => {
        setError(err.message);
      });
  }, [currentUser, file]);

  let importAnnotations;
  if (annotations && selectedUser) {
    importAnnotations = async () => {
      const annsToImport = annotations.filter(ann => ann.user === selectedUser);

      // nb. In the event of an error, `import` will report that directly via
      // a toast message, so we don't do that ourselves.
      importAnnotationsService.import(annsToImport);
    };
  }

  const userSelectId = useId();

  if (!currentUser) {
    // TODO - Make "Log in" a link.
    return (
      <p data-testid="log-in-message">You must log in to import annotations.</p>
    );
  }

  // True if we're validating a JSON file after it has been selected.
  const parseInProgress = file && !annotations && !error;

  // True if we're validating or importing.
  const busy = parseInProgress || importsPending > 0;

  return (
    <>
      <FileInput onFileSelected={setFile} disabled={busy} />
      {userList && (
        <>
          <label htmlFor={userSelectId}>
            <p className="mt-3">
              Select which user&apos;s annotations to import:
            </p>
          </label>
          <Select
            id={userSelectId}
            data-testid="user-list"
            disabled={busy}
            onChange={e =>
              setSelectedUser((e.target as HTMLSelectElement).value || null)
            }
          >
            <option value="" selected={!selectedUser} />
            {userList.map(userInfo => (
              <option
                key={userInfo.userid}
                value={userInfo.userid}
                selected={userInfo.userid === selectedUser}
              >
                {userInfo.displayName} ({userInfo.count})
              </option>
            ))}
          </Select>
        </>
      )}
      {busy && <LoadingSpinner />}
      {error && (
        // TODO - Add a support link here.
        <p data-testid="error-info">
          <b>Unable to find annotations to import:</b> {error}
        </p>
      )}
      <CardActions>
        <Button
          data-testid="import-button"
          disabled={!importAnnotations || busy}
          onClick={importAnnotations}
          variant="primary"
        >
          Import
        </Button>
      </CardActions>
    </>
  );
}

export default withServices(ImportAnnotations, ['importAnnotationsService']);
